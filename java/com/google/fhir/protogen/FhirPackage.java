//    Copyright 2019 Google LLC
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        https://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

package com.google.fhir.protogen;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.base.Ascii;
import com.google.common.io.ByteStreams;
import com.google.fhir.common.InvalidFhirException;
import com.google.fhir.common.JsonFormat;
import com.google.fhir.common.ResourceUtils;
import com.google.fhir.proto.Annotations.FhirVersion;
import com.google.fhir.proto.PackageInfo;
import com.google.fhir.r4.core.Bundle;
import com.google.fhir.r4.core.CodeSystem;
import com.google.fhir.r4.core.SearchParameter;
import com.google.fhir.r4.core.StructureDefinition;
import com.google.fhir.r4.core.ValueSet;
import com.google.protobuf.Message;
import com.google.protobuf.TextFormat;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;

/**
 * Represents a FHIR Proto package.
 *
 * <p>Includes resource definitions and package information.
 *
 * <p>Constructed from an archive file (ZIP or TAR) containing the JSON files of the resources and
 * optionally a PackageInfo file that describes the package. ZIP archives are generated by the
 * `fhir_package` rule in protogen.bzl.
 *
 * <p>TODO: Support NPM-based FHIR Packages for proto generation.
 */
public class FhirPackage {
  public final PackageInfo packageInfo;
  public final List<StructureDefinition> structureDefinitions;
  public final List<SearchParameter> searchParameters;
  public final List<CodeSystem> codeSystems;
  public final List<ValueSet> valueSets;

  public FhirPackage(
      PackageInfo packageInfo,
      List<StructureDefinition> structureDefinitions,
      List<SearchParameter> searchParameters,
      List<CodeSystem> codeSystems,
      List<ValueSet> valueSets) {
    this.packageInfo = packageInfo;
    this.structureDefinitions = structureDefinitions;
    this.searchParameters = searchParameters;
    this.codeSystems = codeSystems;
    this.valueSets = valueSets;
  }

  @Override
  public boolean equals(Object other) {
    return other instanceof FhirPackage
        && ((FhirPackage) other)
            .packageInfo
            .getProtoPackage()
            .equals(packageInfo.getProtoPackage());
  }

  @Override
  public int hashCode() {
    return packageInfo.getProtoPackage().hashCode();
  }

  public static boolean isCorePackage(PackageInfo packageInfo) {
    return packageInfo
        .getProtoPackage()
        .equals(
            com.google.fhir.common.FhirVersion.fromAnnotation(packageInfo.getFhirVersion())
                .coreProtoPackage);
  }

  public boolean isCorePackage() {
    return isCorePackage(packageInfo);
  }

  /**
   * Loads a package archive into a FhirPackage.
   *
   * <p>Parses all defining resources that are part of the spec.
   *
   * <p>A PackageInfo can be provided and must be named with the suffix "package_info.prototxt" or
   * "package_info.textproto".
   *
   * <p>To side load a PackageInfo proto, use the version of this that accepts a PackageInfo proto.
   *
   * <p>TODO: Support NPM-based FHIR Packages for proto generation.
   *
   * @param archiveFilePath The absolute path to the archive file (ZIP or TAR) that is loaded.
   *     Expected to end with ".zip" "tar.gz" or ".tgz".
   */
  public static FhirPackage load(String archiveFilePath) throws IOException, InvalidFhirException {
    return load(archiveFilePath, /*packageInfo=*/ null);
  }

  /**
   * Loads a package ZIP into a FhirPackage.
   *
   * <p>Parses all defining resources that are part of the spec.
   *
   * <p>To read PackageInfo out of the ZIP itself, use the version of this that does not accept a
   * PackageProto argument.
   *
   * @param archiveFilePath The absolute path to the archive file (ZIP or TAR) that is loaded.
   *     Expected to end with ".zip" "tar.gz" or ".tgz".
   * @param packageInfo The package information to load. This package information is used,
   *     irrespective of whether the ZIP contains one.
   */
  public static FhirPackage load(String archiveFilePath, PackageInfo packageInfo)
      throws IOException, InvalidFhirException {
    PackageInfo extractedPackageInfo = null;
    try (ArchiveInputStream archiveEntries = getZipOrTarInputStream(archiveFilePath)) {
      Map<String, String> jsonFiles = new HashMap<>();
      ArchiveEntry entry = null;
      while ((entry = archiveEntries.getNextEntry()) != null) {
        String entryName = Ascii.toLowerCase(entry.getName());
        if (entryName.endsWith(".json")) {
          jsonFiles.put(
              entry.getName(), new String(ByteStreams.toByteArray(archiveEntries), UTF_8));
        } else if (packageInfo == null
            && (entryName.endsWith("package_info.prototxt")
                || entryName.endsWith("package_info.textproto"))) {
          if (extractedPackageInfo != null) {
            throw new IllegalArgumentException(
                "Only one PackageInfo should be provided: " + archiveFilePath);
          }
          String protoTxt = new String(ByteStreams.toByteArray(archiveEntries), UTF_8);
          PackageInfo.Builder infoBuilder = PackageInfo.newBuilder();
          TextFormat.getParser().merge(protoTxt, infoBuilder);
          extractedPackageInfo = infoBuilder.build();
        }
      }

      return makeFromJsonAndPackageInfo(
          jsonFiles, packageInfo == null ? extractedPackageInfo : packageInfo);
    }
  }

  /**
   * Filters the package to only serve resources (`StructureDefinition`-s) matching the provided
   * `filter`.
   *
   * <p>Filters are not additive. In other words, if this method is called multiple times only the
   * latest `filter` is applied.
   */
  FhirPackage filterResources(Predicate<StructureDefinition> filter) {
    return new FhirPackage(
        packageInfo,
        structureDefinitions.stream().filter(filter).collect(Collectors.toList()),
        searchParameters,
        codeSystems,
        valueSets);
  }

  /**
   * Gets the archive input stream from a ZIP or TAR file.
   *
   * @param archiveFilePath The absolute path to the archive file (ZIP or TAR) that is loaded.
   *     Expected to end with ".zip" "tar.gz" or ".tgz".
   */
  private static ArchiveInputStream getZipOrTarInputStream(String archiveFilePath)
      throws IOException {
    FileInputStream fileStream = new FileInputStream(archiveFilePath);
    if (archiveFilePath.endsWith(".zip")) {
      return new ZipArchiveInputStream(fileStream);
    } else if (archiveFilePath.endsWith(".tar.gz") || archiveFilePath.endsWith(".tgz")) {
      return new TarArchiveInputStream(fileStream);
    } else {
      throw new IllegalArgumentException(
          "`archiveFilePath` must end with '.zip', 'tar.gz' or '.tgz': " + archiveFilePath);
    }
  }

  private static final Pattern RESOURCE_TYPE_PATTERN =
      Pattern.compile("\"resourceType\"\\s*:\\s*\"([A-Za-z]*)\"");

  private static Optional<String> getResourceType(String json) {
    Matcher matcher = RESOURCE_TYPE_PATTERN.matcher(json);
    return matcher.find() ? Optional.of(matcher.group(1)) : Optional.empty();
  }

  private static FhirPackage makeFromJsonAndPackageInfo(
      Map<String, String> jsonFiles, PackageInfo packageInfo) throws InvalidFhirException {
    if (packageInfo != null) {
      if (packageInfo.getProtoPackage().isEmpty()) {
        throw new IllegalArgumentException(
            "When PackageInfo is provided, must specify `proto_package`.");
      }
      if (packageInfo.getFhirVersion() == FhirVersion.FHIR_VERSION_UNKNOWN) {
        throw new IllegalArgumentException(
            "When PackageInfo is provided, must specify `fhir_version`.");
      }
    }

    List<ValueSet> valueSets = new ArrayList<>();
    List<CodeSystem> codeSystems = new ArrayList<>();
    List<StructureDefinition> structureDefinitions = new ArrayList<>();
    List<SearchParameter> searchParameters = new ArrayList<>();
    // TODO: Make Fhir Parser injectable.
    JsonFormat.Parser parser =
        packageInfo == null
            ? JsonFormat.getParser()
            : JsonFormat.getSpecParser(packageInfo.getFhirVersion());

    for (Map.Entry<String, String> jsonFile : jsonFiles.entrySet()) {
      String json = jsonFile.getValue();
      Optional<String> expectedType = getResourceType(json);
      if (!expectedType.isPresent()) {
        System.out.println("Unhandled JSON entry: " + jsonFile.getKey());
        continue;
      }

      if (expectedType.get().equals("ValueSet")) {
        valueSets.add(parser.merge(json, ValueSet.newBuilder()).build());
      } else if (expectedType.get().equals("CodeSystem")) {
        codeSystems.add(parser.merge(json, CodeSystem.newBuilder()).build());
      } else if (expectedType.get().equals("StructureDefinition")) {
        structureDefinitions.add(parser.merge(json, StructureDefinition.newBuilder()).build());
      } else if (expectedType.get().equals("SearchParameter")) {
        searchParameters.add(parser.merge(json, SearchParameter.newBuilder()).build());
      } else if (expectedType.get().equals("Bundle")) {
        // TODO: Theoretically a bundle could contain a bundle, modify implementation
        // to accomodate.
        Bundle bundle = parser.merge(json, Bundle.newBuilder()).build();
        for (Bundle.Entry bundleEntry : bundle.getEntryList()) {
          Message contained = ResourceUtils.getContainedResource(bundleEntry.getResource());
          if (contained instanceof ValueSet) {
            valueSets.add((ValueSet) contained);
          } else if (contained instanceof CodeSystem) {
            codeSystems.add((CodeSystem) contained);
          } else if (contained instanceof StructureDefinition) {
            structureDefinitions.add((StructureDefinition) contained);
          } else if (contained instanceof SearchParameter) {
            searchParameters.add((SearchParameter) contained);
          }
        }
      } else {
        System.out.println("Unhandled JSON entry: " + jsonFile.getKey());
      }
    }
    return new FhirPackage(
        packageInfo, structureDefinitions, searchParameters, codeSystems, valueSets);
  }
}
